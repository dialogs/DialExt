/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "dialog.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct DialogRoot {
    public static let `default` = DialogRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}

final public class AppSharedDialog : GeneratedMessage {

    public static func == (lhs: AppSharedDialog, rhs: AppSharedDialog) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasIsGroup == rhs.hasIsGroup) && (!lhs.hasIsGroup || lhs.isGroup == rhs.isGroup)
        fieldCheck = fieldCheck && (lhs.hasTitle == rhs.hasTitle) && (!lhs.hasTitle || lhs.title == rhs.title)
        fieldCheck = fieldCheck && (lhs.uids == rhs.uids)
        fieldCheck = fieldCheck && (lhs.hasIsReadOnly == rhs.hasIsReadOnly) && (!lhs.hasIsReadOnly || lhs.isReadOnly == rhs.isReadOnly)
        fieldCheck = fieldCheck && (lhs.hasAccessHash == rhs.hasAccessHash) && (!lhs.hasAccessHash || lhs.accessHash == rhs.accessHash)
        fieldCheck = fieldCheck && (lhs.hasPeerId == rhs.hasPeerId) && (!lhs.hasPeerId || lhs.peerId == rhs.peerId)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int64 = Int64(0)
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var isGroup:Bool = false
    public fileprivate(set) var hasIsGroup:Bool = false

    public fileprivate(set) var title:String = ""
    public fileprivate(set) var hasTitle:Bool = false

    public fileprivate(set) var uids:Array<Int32> = Array<Int32>()
    private var uidsMemoizedSerializedSize:Int32 = -1
    public fileprivate(set) var isReadOnly:Bool = false
    public fileprivate(set) var hasIsReadOnly:Bool = false

    public fileprivate(set) var accessHash:Int64 = Int64(0)
    public fileprivate(set) var hasAccessHash:Bool = false

    public fileprivate(set) var peerId:Int32 = Int32(0)
    public fileprivate(set) var hasPeerId:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:id)
        }
        if hasIsGroup {
            try codedOutputStream.writeBool(fieldNumber: 2, value:isGroup)
        }
        if hasTitle {
            try codedOutputStream.writeString(fieldNumber: 3, value:title)
        }
        if !uids.isEmpty {
            try codedOutputStream.writeRawVarint32(value: 34)
            try codedOutputStream.writeRawVarint32(value: uidsMemoizedSerializedSize)
            for oneValueuids in uids {
                try codedOutputStream.writeInt32NoTag(value: oneValueuids)
            }
        }
        if hasIsReadOnly {
            try codedOutputStream.writeBool(fieldNumber: 5, value:isReadOnly)
        }
        if hasAccessHash {
            try codedOutputStream.writeInt64(fieldNumber: 6, value:accessHash)
        }
        if hasPeerId {
            try codedOutputStream.writeInt32(fieldNumber: 7, value:peerId)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt64Size(fieldNumber: 1)
        }
        if hasIsGroup {
            serialize_size += isGroup.computeBoolSize(fieldNumber: 2)
        }
        if hasTitle {
            serialize_size += title.computeStringSize(fieldNumber: 3)
        }
        var dataSizeUids:Int32 = 0
        for oneValueuids in uids {
            dataSizeUids += oneValueuids.computeInt32SizeNoTag()
        }
        serialize_size += dataSizeUids
        if !uids.isEmpty {
            serialize_size += 1
            serialize_size += dataSizeUids.computeInt32SizeNoTag()
        }
        uidsMemoizedSerializedSize = dataSizeUids
        if hasIsReadOnly {
            serialize_size += isReadOnly.computeBoolSize(fieldNumber: 5)
        }
        if hasAccessHash {
            serialize_size += accessHash.computeInt64Size(fieldNumber: 6)
        }
        if hasPeerId {
            serialize_size += peerId.computeInt32Size(fieldNumber: 7)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> AppSharedDialog.Builder {
        return AppSharedDialog.classBuilder() as! AppSharedDialog.Builder
    }
    public func getBuilder() -> AppSharedDialog.Builder {
        return classBuilder() as! AppSharedDialog.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AppSharedDialog.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AppSharedDialog.Builder()
    }
    public func toBuilder() throws -> AppSharedDialog.Builder {
        return try AppSharedDialog.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:AppSharedDialog) throws -> AppSharedDialog.Builder {
        return try AppSharedDialog.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasId {
            jsonMap["id"] = "\(id)"
        }
        if hasIsGroup {
            jsonMap["isGroup"] = isGroup
        }
        if hasTitle {
            jsonMap["title"] = title
        }
        if !uids.isEmpty {
            var jsonArrayUids:Array<Int> = []
            for oneValueUids in uids {
                jsonArrayUids.append(Int(oneValueUids))
            }
            jsonMap["uids"] = jsonArrayUids
        }
        if hasIsReadOnly {
            jsonMap["isReadOnly"] = isReadOnly
        }
        if hasAccessHash {
            jsonMap["accessHash"] = "\(accessHash)"
        }
        if hasPeerId {
            jsonMap["peerId"] = Int(peerId)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> AppSharedDialog {
        return try AppSharedDialog.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> AppSharedDialog {
        return try AppSharedDialog.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasIsGroup {
            output += "\(indent) isGroup: \(isGroup) \n"
        }
        if hasTitle {
            output += "\(indent) title: \(title) \n"
        }
        var uidsElementIndex:Int = 0
        for oneValueUids in uids  {
            output += "\(indent) uids[\(uidsElementIndex)]: \(oneValueUids)\n"
            uidsElementIndex += 1
        }
        if hasIsReadOnly {
            output += "\(indent) isReadOnly: \(isReadOnly) \n"
        }
        if hasAccessHash {
            output += "\(indent) accessHash: \(accessHash) \n"
        }
        if hasPeerId {
            output += "\(indent) peerId: \(peerId) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasIsGroup {
                hashCode = (hashCode &* 31) &+ isGroup.hashValue
            }
            if hasTitle {
                hashCode = (hashCode &* 31) &+ title.hashValue
            }
            for oneValueUids in uids {
                hashCode = (hashCode &* 31) &+ oneValueUids.hashValue
            }
            if hasIsReadOnly {
                hashCode = (hashCode &* 31) &+ isReadOnly.hashValue
            }
            if hasAccessHash {
                hashCode = (hashCode &* 31) &+ accessHash.hashValue
            }
            if hasPeerId {
                hashCode = (hashCode &* 31) &+ peerId.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "AppSharedDialog"
    }
    override public func className() -> String {
        return "AppSharedDialog"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:AppSharedDialog = AppSharedDialog()
        public func getMessage() -> AppSharedDialog {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int64 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int64) -> AppSharedDialog.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> AppSharedDialog.Builder{
            builderResult.hasId = false
            builderResult.id = Int64(0)
            return self
        }
        public var isGroup:Bool {
            get {
                return builderResult.isGroup
            }
            set (value) {
                builderResult.hasIsGroup = true
                builderResult.isGroup = value
            }
        }
        public var hasIsGroup:Bool {
            get {
                return builderResult.hasIsGroup
            }
        }
        @discardableResult
        public func setIsGroup(_ value:Bool) -> AppSharedDialog.Builder {
            self.isGroup = value
            return self
        }
        @discardableResult
        public func clearIsGroup() -> AppSharedDialog.Builder{
            builderResult.hasIsGroup = false
            builderResult.isGroup = false
            return self
        }
        public var title:String {
            get {
                return builderResult.title
            }
            set (value) {
                builderResult.hasTitle = true
                builderResult.title = value
            }
        }
        public var hasTitle:Bool {
            get {
                return builderResult.hasTitle
            }
        }
        @discardableResult
        public func setTitle(_ value:String) -> AppSharedDialog.Builder {
            self.title = value
            return self
        }
        @discardableResult
        public func clearTitle() -> AppSharedDialog.Builder{
            builderResult.hasTitle = false
            builderResult.title = ""
            return self
        }
        public var uids:Array<Int32> {
            get {
                return builderResult.uids
            }
            set (array) {
                builderResult.uids = array
            }
        }
        @discardableResult
        public func setUids(_ value:Array<Int32>) -> AppSharedDialog.Builder {
            self.uids = value
            return self
        }
        @discardableResult
        public func clearUids() -> AppSharedDialog.Builder {
            builderResult.uids.removeAll(keepingCapacity: false)
            return self
        }
        public var isReadOnly:Bool {
            get {
                return builderResult.isReadOnly
            }
            set (value) {
                builderResult.hasIsReadOnly = true
                builderResult.isReadOnly = value
            }
        }
        public var hasIsReadOnly:Bool {
            get {
                return builderResult.hasIsReadOnly
            }
        }
        @discardableResult
        public func setIsReadOnly(_ value:Bool) -> AppSharedDialog.Builder {
            self.isReadOnly = value
            return self
        }
        @discardableResult
        public func clearIsReadOnly() -> AppSharedDialog.Builder{
            builderResult.hasIsReadOnly = false
            builderResult.isReadOnly = false
            return self
        }
        public var accessHash:Int64 {
            get {
                return builderResult.accessHash
            }
            set (value) {
                builderResult.hasAccessHash = true
                builderResult.accessHash = value
            }
        }
        public var hasAccessHash:Bool {
            get {
                return builderResult.hasAccessHash
            }
        }
        @discardableResult
        public func setAccessHash(_ value:Int64) -> AppSharedDialog.Builder {
            self.accessHash = value
            return self
        }
        @discardableResult
        public func clearAccessHash() -> AppSharedDialog.Builder{
            builderResult.hasAccessHash = false
            builderResult.accessHash = Int64(0)
            return self
        }
        public var peerId:Int32 {
            get {
                return builderResult.peerId
            }
            set (value) {
                builderResult.hasPeerId = true
                builderResult.peerId = value
            }
        }
        public var hasPeerId:Bool {
            get {
                return builderResult.hasPeerId
            }
        }
        @discardableResult
        public func setPeerId(_ value:Int32) -> AppSharedDialog.Builder {
            self.peerId = value
            return self
        }
        @discardableResult
        public func clearPeerId() -> AppSharedDialog.Builder{
            builderResult.hasPeerId = false
            builderResult.peerId = Int32(0)
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> AppSharedDialog.Builder {
            builderResult = AppSharedDialog()
            return self
        }
        override public func clone() throws -> AppSharedDialog.Builder {
            return try AppSharedDialog.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> AppSharedDialog {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> AppSharedDialog {
            let returnMe:AppSharedDialog = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:AppSharedDialog) throws -> AppSharedDialog.Builder {
            if other == AppSharedDialog() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasIsGroup {
                isGroup = other.isGroup
            }
            if other.hasTitle {
                title = other.title
            }
            if !other.uids.isEmpty {
                builderResult.uids += other.uids
            }
            if other.hasIsReadOnly {
                isReadOnly = other.isReadOnly
            }
            if other.hasAccessHash {
                accessHash = other.accessHash
            }
            if other.hasPeerId {
                peerId = other.peerId
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> AppSharedDialog.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AppSharedDialog.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt64()

                case 16:
                    isGroup = try codedInputStream.readBool()

                case 26:
                    title = try codedInputStream.readString()

                case 34:
                    let length = Int(try codedInputStream.readRawVarint32())
                    let limit = try codedInputStream.pushLimit(byteLimit: length)
                    while (codedInputStream.bytesUntilLimit() > 0) {
                        builderResult.uids.append(try codedInputStream.readInt32())
                    }
                    codedInputStream.popLimit(oldLimit: limit)

                case 40:
                    isReadOnly = try codedInputStream.readBool()

                case 48:
                    accessHash = try codedInputStream.readInt64()

                case 56:
                    peerId = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> AppSharedDialog.Builder {
            let resultDecodedBuilder = AppSharedDialog.Builder()
            if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int64(jsonValueId)!
            } else if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int64(jsonValueId)
            }
            if let jsonValueIsGroup = jsonMap["isGroup"] as? Bool {
                resultDecodedBuilder.isGroup = jsonValueIsGroup
            }
            if let jsonValueTitle = jsonMap["title"] as? String {
                resultDecodedBuilder.title = jsonValueTitle
            }
            if let jsonValueUids = jsonMap["uids"] as? Array<Int> {
                var jsonArrayUids:Array<Int32> = []
                for oneValueUids in jsonValueUids {
                    jsonArrayUids.append(Int32(oneValueUids))
                }
                resultDecodedBuilder.uids = jsonArrayUids
            }
            if let jsonValueIsReadOnly = jsonMap["isReadOnly"] as? Bool {
                resultDecodedBuilder.isReadOnly = jsonValueIsReadOnly
            }
            if let jsonValueAccessHash = jsonMap["accessHash"] as? String {
                resultDecodedBuilder.accessHash = Int64(jsonValueAccessHash)!
            } else if let jsonValueAccessHash = jsonMap["accessHash"] as? Int {
                resultDecodedBuilder.accessHash = Int64(jsonValueAccessHash)
            }
            if let jsonValuePeerId = jsonMap["peerId"] as? Int {
                resultDecodedBuilder.peerId = Int32(jsonValuePeerId)
            } else if let jsonValuePeerId = jsonMap["peerId"] as? String {
                resultDecodedBuilder.peerId = Int32(jsonValuePeerId)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> AppSharedDialog.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try AppSharedDialog.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class AppSharedUser : GeneratedMessage {

    public static func == (lhs: AppSharedUser, rhs: AppSharedUser) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int32 = Int32(0)
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var name:String = ""
    public fileprivate(set) var hasName:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:id)
        }
        if hasName {
            try codedOutputStream.writeString(fieldNumber: 2, value:name)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt32Size(fieldNumber: 1)
        }
        if hasName {
            serialize_size += name.computeStringSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> AppSharedUser.Builder {
        return AppSharedUser.classBuilder() as! AppSharedUser.Builder
    }
    public func getBuilder() -> AppSharedUser.Builder {
        return classBuilder() as! AppSharedUser.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AppSharedUser.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AppSharedUser.Builder()
    }
    public func toBuilder() throws -> AppSharedUser.Builder {
        return try AppSharedUser.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:AppSharedUser) throws -> AppSharedUser.Builder {
        return try AppSharedUser.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasId {
            jsonMap["id"] = Int(id)
        }
        if hasName {
            jsonMap["name"] = name
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> AppSharedUser {
        return try AppSharedUser.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> AppSharedUser {
        return try AppSharedUser.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasName {
            output += "\(indent) name: \(name) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasName {
                hashCode = (hashCode &* 31) &+ name.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "AppSharedUser"
    }
    override public func className() -> String {
        return "AppSharedUser"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:AppSharedUser = AppSharedUser()
        public func getMessage() -> AppSharedUser {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int32 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int32) -> AppSharedUser.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> AppSharedUser.Builder{
            builderResult.hasId = false
            builderResult.id = Int32(0)
            return self
        }
        public var name:String {
            get {
                return builderResult.name
            }
            set (value) {
                builderResult.hasName = true
                builderResult.name = value
            }
        }
        public var hasName:Bool {
            get {
                return builderResult.hasName
            }
        }
        @discardableResult
        public func setName(_ value:String) -> AppSharedUser.Builder {
            self.name = value
            return self
        }
        @discardableResult
        public func clearName() -> AppSharedUser.Builder{
            builderResult.hasName = false
            builderResult.name = ""
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> AppSharedUser.Builder {
            builderResult = AppSharedUser()
            return self
        }
        override public func clone() throws -> AppSharedUser.Builder {
            return try AppSharedUser.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> AppSharedUser {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> AppSharedUser {
            let returnMe:AppSharedUser = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:AppSharedUser) throws -> AppSharedUser.Builder {
            if other == AppSharedUser() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasName {
                name = other.name
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> AppSharedUser.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AppSharedUser.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt32()

                case 18:
                    name = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> AppSharedUser.Builder {
            let resultDecodedBuilder = AppSharedUser.Builder()
            if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int32(jsonValueId)
            } else if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int32(jsonValueId)!
            }
            if let jsonValueName = jsonMap["name"] as? String {
                resultDecodedBuilder.name = jsonValueName
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> AppSharedUser.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try AppSharedUser.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class AppSharedDialogListContext : GeneratedMessage {

    public static func == (lhs: AppSharedDialogListContext, rhs: AppSharedDialogListContext) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.dialogs == rhs.dialogs)
        fieldCheck = fieldCheck && (lhs.users == rhs.users)
        fieldCheck = fieldCheck && (lhs.hasMainUser == rhs.hasMainUser) && (!lhs.hasMainUser || lhs.mainUser == rhs.mainUser)
        fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var dialogs:Array<AppSharedDialog>  = Array<AppSharedDialog>()
    public fileprivate(set) var users:Array<AppSharedUser>  = Array<AppSharedUser>()
    public fileprivate(set) var mainUser:AppSharedUser!
    public fileprivate(set) var hasMainUser:Bool = false
    public fileprivate(set) var version:String = ""
    public fileprivate(set) var hasVersion:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        for oneElementDialogs in dialogs {
              try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementDialogs)
        }
        for oneElementUsers in users {
              try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementUsers)
        }
        if hasMainUser {
            try codedOutputStream.writeMessage(fieldNumber: 3, value:mainUser)
        }
        if hasVersion {
            try codedOutputStream.writeString(fieldNumber: 4, value:version)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        for oneElementDialogs in dialogs {
            serialize_size += oneElementDialogs.computeMessageSize(fieldNumber: 1)
        }
        for oneElementUsers in users {
            serialize_size += oneElementUsers.computeMessageSize(fieldNumber: 2)
        }
        if hasMainUser {
            if let varSizemainUser = mainUser?.computeMessageSize(fieldNumber: 3) {
                serialize_size += varSizemainUser
            }
        }
        if hasVersion {
            serialize_size += version.computeStringSize(fieldNumber: 4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> AppSharedDialogListContext.Builder {
        return AppSharedDialogListContext.classBuilder() as! AppSharedDialogListContext.Builder
    }
    public func getBuilder() -> AppSharedDialogListContext.Builder {
        return classBuilder() as! AppSharedDialogListContext.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AppSharedDialogListContext.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AppSharedDialogListContext.Builder()
    }
    public func toBuilder() throws -> AppSharedDialogListContext.Builder {
        return try AppSharedDialogListContext.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:AppSharedDialogListContext) throws -> AppSharedDialogListContext.Builder {
        return try AppSharedDialogListContext.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if !dialogs.isEmpty {
            var jsonArrayDialogs:Array<Dictionary<String,Any>> = []
            for oneValueDialogs in dialogs {
                let ecodedMessageDialogs = try oneValueDialogs.encode()
                jsonArrayDialogs.append(ecodedMessageDialogs)
            }
            jsonMap["dialogs"] = jsonArrayDialogs
        }
        if !users.isEmpty {
            var jsonArrayUsers:Array<Dictionary<String,Any>> = []
            for oneValueUsers in users {
                let ecodedMessageUsers = try oneValueUsers.encode()
                jsonArrayUsers.append(ecodedMessageUsers)
            }
            jsonMap["users"] = jsonArrayUsers
        }
        if hasMainUser {
            jsonMap["mainUser"] = try mainUser.encode()
        }
        if hasVersion {
            jsonMap["version"] = version
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> AppSharedDialogListContext {
        return try AppSharedDialogListContext.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> AppSharedDialogListContext {
        return try AppSharedDialogListContext.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        var dialogsElementIndex:Int = 0
        for oneElementDialogs in dialogs {
            output += "\(indent) dialogs[\(dialogsElementIndex)] {\n"
            output += try oneElementDialogs.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            dialogsElementIndex += 1
        }
        var usersElementIndex:Int = 0
        for oneElementUsers in users {
            output += "\(indent) users[\(usersElementIndex)] {\n"
            output += try oneElementUsers.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            usersElementIndex += 1
        }
        if hasMainUser {
            output += "\(indent) mainUser {\n"
            if let outDescMainUser = mainUser {
                output += try outDescMainUser.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasVersion {
            output += "\(indent) version: \(version) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementDialogs in dialogs {
                hashCode = (hashCode &* 31) &+ oneElementDialogs.hashValue
            }
            for oneElementUsers in users {
                hashCode = (hashCode &* 31) &+ oneElementUsers.hashValue
            }
            if hasMainUser {
                if let hashValuemainUser = mainUser?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuemainUser
                }
            }
            if hasVersion {
                hashCode = (hashCode &* 31) &+ version.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "AppSharedDialogListContext"
    }
    override public func className() -> String {
        return "AppSharedDialogListContext"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:AppSharedDialogListContext = AppSharedDialogListContext()
        public func getMessage() -> AppSharedDialogListContext {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var dialogs:Array<AppSharedDialog> {
            get {
                return builderResult.dialogs
            }
            set (value) {
                builderResult.dialogs = value
            }
        }
        @discardableResult
        public func setDialogs(_ value:Array<AppSharedDialog>) -> AppSharedDialogListContext.Builder {
            self.dialogs = value
            return self
        }
        @discardableResult
        public func clearDialogs() -> AppSharedDialogListContext.Builder {
            builderResult.dialogs.removeAll(keepingCapacity: false)
            return self
        }
        public var users:Array<AppSharedUser> {
            get {
                return builderResult.users
            }
            set (value) {
                builderResult.users = value
            }
        }
        @discardableResult
        public func setUsers(_ value:Array<AppSharedUser>) -> AppSharedDialogListContext.Builder {
            self.users = value
            return self
        }
        @discardableResult
        public func clearUsers() -> AppSharedDialogListContext.Builder {
            builderResult.users.removeAll(keepingCapacity: false)
            return self
        }
        public var mainUser:AppSharedUser! {
            get {
                if mainUserBuilder_ != nil {
                    builderResult.mainUser = mainUserBuilder_.getMessage()
                }
                return builderResult.mainUser
            }
            set (value) {
                builderResult.hasMainUser = true
                builderResult.mainUser = value
            }
        }
        public var hasMainUser:Bool {
            get {
                return builderResult.hasMainUser
            }
        }
        fileprivate var mainUserBuilder_:AppSharedUser.Builder! {
            didSet {
                builderResult.hasMainUser = true
            }
        }
        public func getMainUserBuilder() -> AppSharedUser.Builder {
            if mainUserBuilder_ == nil {
                mainUserBuilder_ = AppSharedUser.Builder()
                builderResult.mainUser = mainUserBuilder_.getMessage()
                if mainUser != nil {
                    try! mainUserBuilder_.mergeFrom(other: mainUser)
                }
            }
            return mainUserBuilder_
        }
        @discardableResult
        public func setMainUser(_ value:AppSharedUser!) -> AppSharedDialogListContext.Builder {
            self.mainUser = value
            return self
        }
        @discardableResult
        public func mergeMainUser(value:AppSharedUser) throws -> AppSharedDialogListContext.Builder {
            if builderResult.hasMainUser {
                builderResult.mainUser = try AppSharedUser.builderWithPrototype(prototype:builderResult.mainUser).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.mainUser = value
            }
            builderResult.hasMainUser = true
            return self
        }
        @discardableResult
        public func clearMainUser() -> AppSharedDialogListContext.Builder {
            mainUserBuilder_ = nil
            builderResult.hasMainUser = false
            builderResult.mainUser = nil
            return self
        }
        public var version:String {
            get {
                return builderResult.version
            }
            set (value) {
                builderResult.hasVersion = true
                builderResult.version = value
            }
        }
        public var hasVersion:Bool {
            get {
                return builderResult.hasVersion
            }
        }
        @discardableResult
        public func setVersion(_ value:String) -> AppSharedDialogListContext.Builder {
            self.version = value
            return self
        }
        @discardableResult
        public func clearVersion() -> AppSharedDialogListContext.Builder{
            builderResult.hasVersion = false
            builderResult.version = ""
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> AppSharedDialogListContext.Builder {
            builderResult = AppSharedDialogListContext()
            return self
        }
        override public func clone() throws -> AppSharedDialogListContext.Builder {
            return try AppSharedDialogListContext.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> AppSharedDialogListContext {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> AppSharedDialogListContext {
            let returnMe:AppSharedDialogListContext = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:AppSharedDialogListContext) throws -> AppSharedDialogListContext.Builder {
            if other == AppSharedDialogListContext() {
                return self
            }
            if !other.dialogs.isEmpty  {
                 builderResult.dialogs += other.dialogs
            }
            if !other.users.isEmpty  {
                 builderResult.users += other.users
            }
            if (other.hasMainUser) {
                try mergeMainUser(value: other.mainUser)
            }
            if other.hasVersion {
                version = other.version
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> AppSharedDialogListContext.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AppSharedDialogListContext.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder = AppSharedDialog.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    dialogs.append(subBuilder.buildPartial())

                case 18:
                    let subBuilder = AppSharedUser.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    users.append(subBuilder.buildPartial())

                case 26:
                    let subBuilder:AppSharedUser.Builder = AppSharedUser.Builder()
                    if hasMainUser {
                        try subBuilder.mergeFrom(other: mainUser)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    mainUser = subBuilder.buildPartial()

                case 34:
                    version = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> AppSharedDialogListContext.Builder {
            let resultDecodedBuilder = AppSharedDialogListContext.Builder()
            if let jsonValueDialogs = jsonMap["dialogs"] as? Array<Dictionary<String,Any>> {
                var jsonArrayDialogs:Array<AppSharedDialog> = []
                for oneValueDialogs in jsonValueDialogs {
                    let messageFromStringDialogs = try AppSharedDialog.Builder.decodeToBuilder(jsonMap:oneValueDialogs).build()

                    jsonArrayDialogs.append(messageFromStringDialogs)
                }
                resultDecodedBuilder.dialogs = jsonArrayDialogs
            }
            if let jsonValueUsers = jsonMap["users"] as? Array<Dictionary<String,Any>> {
                var jsonArrayUsers:Array<AppSharedUser> = []
                for oneValueUsers in jsonValueUsers {
                    let messageFromStringUsers = try AppSharedUser.Builder.decodeToBuilder(jsonMap:oneValueUsers).build()

                    jsonArrayUsers.append(messageFromStringUsers)
                }
                resultDecodedBuilder.users = jsonArrayUsers
            }
            if let jsonValueMainUser = jsonMap["mainUser"] as? Dictionary<String,Any> {
                resultDecodedBuilder.mainUser = try AppSharedUser.Builder.decodeToBuilder(jsonMap:jsonValueMainUser).build()

            }
            if let jsonValueVersion = jsonMap["version"] as? String {
                resultDecodedBuilder.version = jsonValueVersion
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> AppSharedDialogListContext.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try AppSharedDialogListContext.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class AppSharedDialogList : GeneratedMessage {

    public static func == (lhs: AppSharedDialogList, rhs: AppSharedDialogList) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.ids == rhs.ids)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var ids:Array<Int64> = Array<Int64>()
    private var idsMemoizedSerializedSize:Int32 = -1
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if !ids.isEmpty {
            try codedOutputStream.writeRawVarint32(value: 10)
            try codedOutputStream.writeRawVarint32(value: idsMemoizedSerializedSize)
            for oneValueids in ids {
                try codedOutputStream.writeInt64NoTag(value: oneValueids)
            }
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        var dataSizeIds:Int32 = 0
        for oneValueids in ids {
            dataSizeIds += oneValueids.computeInt64SizeNoTag()
        }
        serialize_size += dataSizeIds
        if !ids.isEmpty {
            serialize_size += 1
            serialize_size += dataSizeIds.computeInt32SizeNoTag()
        }
        idsMemoizedSerializedSize = dataSizeIds
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> AppSharedDialogList.Builder {
        return AppSharedDialogList.classBuilder() as! AppSharedDialogList.Builder
    }
    public func getBuilder() -> AppSharedDialogList.Builder {
        return classBuilder() as! AppSharedDialogList.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AppSharedDialogList.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AppSharedDialogList.Builder()
    }
    public func toBuilder() throws -> AppSharedDialogList.Builder {
        return try AppSharedDialogList.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:AppSharedDialogList) throws -> AppSharedDialogList.Builder {
        return try AppSharedDialogList.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if !ids.isEmpty {
            var jsonArrayIds:Array<String> = []
            for oneValueIds in ids {
                jsonArrayIds.append("\(oneValueIds)")
            }
            jsonMap["ids"] = jsonArrayIds
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> AppSharedDialogList {
        return try AppSharedDialogList.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> AppSharedDialogList {
        return try AppSharedDialogList.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        var idsElementIndex:Int = 0
        for oneValueIds in ids  {
            output += "\(indent) ids[\(idsElementIndex)]: \(oneValueIds)\n"
            idsElementIndex += 1
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneValueIds in ids {
                hashCode = (hashCode &* 31) &+ oneValueIds.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "AppSharedDialogList"
    }
    override public func className() -> String {
        return "AppSharedDialogList"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:AppSharedDialogList = AppSharedDialogList()
        public func getMessage() -> AppSharedDialogList {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var ids:Array<Int64> {
            get {
                return builderResult.ids
            }
            set (array) {
                builderResult.ids = array
            }
        }
        @discardableResult
        public func setIds(_ value:Array<Int64>) -> AppSharedDialogList.Builder {
            self.ids = value
            return self
        }
        @discardableResult
        public func clearIds() -> AppSharedDialogList.Builder {
            builderResult.ids.removeAll(keepingCapacity: false)
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> AppSharedDialogList.Builder {
            builderResult = AppSharedDialogList()
            return self
        }
        override public func clone() throws -> AppSharedDialogList.Builder {
            return try AppSharedDialogList.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> AppSharedDialogList {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> AppSharedDialogList {
            let returnMe:AppSharedDialogList = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:AppSharedDialogList) throws -> AppSharedDialogList.Builder {
            if other == AppSharedDialogList() {
                return self
            }
            if !other.ids.isEmpty {
                builderResult.ids += other.ids
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> AppSharedDialogList.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AppSharedDialogList.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let length = Int(try codedInputStream.readRawVarint32())
                    let limit = try codedInputStream.pushLimit(byteLimit: length)
                    while (codedInputStream.bytesUntilLimit() > 0) {
                        builderResult.ids.append(try codedInputStream.readInt64())
                    }
                    codedInputStream.popLimit(oldLimit: limit)

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> AppSharedDialogList.Builder {
            let resultDecodedBuilder = AppSharedDialogList.Builder()
            if let jsonValueIds = jsonMap["ids"] as? Array<String> {
                var jsonArrayIds:Array<Int64> = []
                for oneValueIds in jsonValueIds {
                    jsonArrayIds.append(Int64(oneValueIds)!)
                }
                resultDecodedBuilder.ids = jsonArrayIds
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> AppSharedDialogList.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try AppSharedDialogList.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension AppSharedDialog: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<AppSharedDialog> {
        var mergedArray = Array<AppSharedDialog>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> AppSharedDialog? {
        return try AppSharedDialog.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> AppSharedDialog {
        return try AppSharedDialog.Builder().mergeFrom(data: data, extensionRegistry:DialogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> AppSharedDialog {
        return try AppSharedDialog.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> AppSharedDialog {
        return try AppSharedDialog.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> AppSharedDialog {
        return try AppSharedDialog.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> AppSharedDialog {
        return try AppSharedDialog.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AppSharedDialog {
        return try AppSharedDialog.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "isGroup": return self.isGroup
        case "title": return self.title
        case "uids": return self.uids
        case "isReadOnly": return self.isReadOnly
        case "accessHash": return self.accessHash
        case "peerId": return self.peerId
        default: return nil
        }
    }
}
extension AppSharedDialog.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "isGroup": return self.isGroup
            case "title": return self.title
            case "uids": return self.uids
            case "isReadOnly": return self.isReadOnly
            case "accessHash": return self.accessHash
            case "peerId": return self.peerId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.id = newSubscriptValue
            case "isGroup":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isGroup = newSubscriptValue
            case "title":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.title = newSubscriptValue
            case "uids":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int32> else {
                    return
                }
                self.uids = newSubscriptValue
            case "isReadOnly":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isReadOnly = newSubscriptValue
            case "accessHash":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.accessHash = newSubscriptValue
            case "peerId":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.peerId = newSubscriptValue
            default: return
            }
        }
    }
}
extension AppSharedUser: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<AppSharedUser> {
        var mergedArray = Array<AppSharedUser>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> AppSharedUser? {
        return try AppSharedUser.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> AppSharedUser {
        return try AppSharedUser.Builder().mergeFrom(data: data, extensionRegistry:DialogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> AppSharedUser {
        return try AppSharedUser.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> AppSharedUser {
        return try AppSharedUser.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> AppSharedUser {
        return try AppSharedUser.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> AppSharedUser {
        return try AppSharedUser.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AppSharedUser {
        return try AppSharedUser.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "name": return self.name
        default: return nil
        }
    }
}
extension AppSharedUser.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "name": return self.name
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.id = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            default: return
            }
        }
    }
}
extension AppSharedDialogListContext: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<AppSharedDialogListContext> {
        var mergedArray = Array<AppSharedDialogListContext>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> AppSharedDialogListContext? {
        return try AppSharedDialogListContext.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> AppSharedDialogListContext {
        return try AppSharedDialogListContext.Builder().mergeFrom(data: data, extensionRegistry:DialogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> AppSharedDialogListContext {
        return try AppSharedDialogListContext.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> AppSharedDialogListContext {
        return try AppSharedDialogListContext.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> AppSharedDialogListContext {
        return try AppSharedDialogListContext.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> AppSharedDialogListContext {
        return try AppSharedDialogListContext.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AppSharedDialogListContext {
        return try AppSharedDialogListContext.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "dialogs": return self.dialogs
        case "users": return self.users
        case "mainUser": return self.mainUser
        case "version": return self.version
        default: return nil
        }
    }
}
extension AppSharedDialogListContext.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "dialogs": return self.dialogs
            case "users": return self.users
            case "mainUser": return self.mainUser
            case "version": return self.version
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "dialogs":
                guard let newSubscriptValue = newSubscriptValue as? Array<AppSharedDialog> else {
                    return
                }
                self.dialogs = newSubscriptValue
            case "users":
                guard let newSubscriptValue = newSubscriptValue as? Array<AppSharedUser> else {
                    return
                }
                self.users = newSubscriptValue
            case "mainUser":
                guard let newSubscriptValue = newSubscriptValue as? AppSharedUser else {
                    return
                }
                self.mainUser = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.version = newSubscriptValue
            default: return
            }
        }
    }
}
extension AppSharedDialogList: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<AppSharedDialogList> {
        var mergedArray = Array<AppSharedDialogList>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> AppSharedDialogList? {
        return try AppSharedDialogList.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> AppSharedDialogList {
        return try AppSharedDialogList.Builder().mergeFrom(data: data, extensionRegistry:DialogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> AppSharedDialogList {
        return try AppSharedDialogList.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> AppSharedDialogList {
        return try AppSharedDialogList.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> AppSharedDialogList {
        return try AppSharedDialogList.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> AppSharedDialogList {
        return try AppSharedDialogList.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AppSharedDialogList {
        return try AppSharedDialogList.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "ids": return self.ids
        default: return nil
        }
    }
}
extension AppSharedDialogList.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "ids": return self.ids
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "ids":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int64> else {
                    return
                }
                self.ids = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
