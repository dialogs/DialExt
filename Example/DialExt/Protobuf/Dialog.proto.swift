/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "dialog.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct DialogRoot {
    public static let `default` = DialogRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}

final public class Dialog : GeneratedMessage {

    public static func == (lhs: Dialog, rhs: Dialog) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasIsGroup == rhs.hasIsGroup) && (!lhs.hasIsGroup || lhs.isGroup == rhs.isGroup)
        fieldCheck = fieldCheck && (lhs.hasTitle == rhs.hasTitle) && (!lhs.hasTitle || lhs.title == rhs.title)
        fieldCheck = fieldCheck && (lhs.uid == rhs.uid)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int64 = Int64(0)
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var isGroup:Bool = false
    public fileprivate(set) var hasIsGroup:Bool = false

    public fileprivate(set) var title:String = ""
    public fileprivate(set) var hasTitle:Bool = false

    public fileprivate(set) var uid:Array<Int32> = Array<Int32>()
    private var uidMemoizedSerializedSize:Int32 = -1
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:id)
        }
        if hasIsGroup {
            try codedOutputStream.writeBool(fieldNumber: 2, value:isGroup)
        }
        if hasTitle {
            try codedOutputStream.writeString(fieldNumber: 3, value:title)
        }
        if !uid.isEmpty {
            try codedOutputStream.writeRawVarint32(value: 34)
            try codedOutputStream.writeRawVarint32(value: uidMemoizedSerializedSize)
            for oneValueuid in uid {
                try codedOutputStream.writeInt32NoTag(value: oneValueuid)
            }
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt64Size(fieldNumber: 1)
        }
        if hasIsGroup {
            serialize_size += isGroup.computeBoolSize(fieldNumber: 2)
        }
        if hasTitle {
            serialize_size += title.computeStringSize(fieldNumber: 3)
        }
        var dataSizeUid:Int32 = 0
        for oneValueuid in uid {
            dataSizeUid += oneValueuid.computeInt32SizeNoTag()
        }
        serialize_size += dataSizeUid
        if !uid.isEmpty {
            serialize_size += 1
            serialize_size += dataSizeUid.computeInt32SizeNoTag()
        }
        uidMemoizedSerializedSize = dataSizeUid
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Dialog.Builder {
        return Dialog.classBuilder() as! Dialog.Builder
    }
    public func getBuilder() -> Dialog.Builder {
        return classBuilder() as! Dialog.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Dialog.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Dialog.Builder()
    }
    public func toBuilder() throws -> Dialog.Builder {
        return try Dialog.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Dialog) throws -> Dialog.Builder {
        return try Dialog.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasId {
            jsonMap["id"] = "\(id)"
        }
        if hasIsGroup {
            jsonMap["isGroup"] = isGroup
        }
        if hasTitle {
            jsonMap["title"] = title
        }
        if !uid.isEmpty {
            var jsonArrayUid:Array<Int> = []
            for oneValueUid in uid {
                jsonArrayUid.append(Int(oneValueUid))
            }
            jsonMap["uid"] = jsonArrayUid
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Dialog {
        return try Dialog.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Dialog {
        return try Dialog.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasIsGroup {
            output += "\(indent) isGroup: \(isGroup) \n"
        }
        if hasTitle {
            output += "\(indent) title: \(title) \n"
        }
        var uidElementIndex:Int = 0
        for oneValueUid in uid  {
            output += "\(indent) uid[\(uidElementIndex)]: \(oneValueUid)\n"
            uidElementIndex += 1
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasIsGroup {
                hashCode = (hashCode &* 31) &+ isGroup.hashValue
            }
            if hasTitle {
                hashCode = (hashCode &* 31) &+ title.hashValue
            }
            for oneValueUid in uid {
                hashCode = (hashCode &* 31) &+ oneValueUid.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Dialog"
    }
    override public func className() -> String {
        return "Dialog"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Dialog = Dialog()
        public func getMessage() -> Dialog {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int64 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int64) -> Dialog.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> Dialog.Builder{
            builderResult.hasId = false
            builderResult.id = Int64(0)
            return self
        }
        public var isGroup:Bool {
            get {
                return builderResult.isGroup
            }
            set (value) {
                builderResult.hasIsGroup = true
                builderResult.isGroup = value
            }
        }
        public var hasIsGroup:Bool {
            get {
                return builderResult.hasIsGroup
            }
        }
        @discardableResult
        public func setIsGroup(_ value:Bool) -> Dialog.Builder {
            self.isGroup = value
            return self
        }
        @discardableResult
        public func clearIsGroup() -> Dialog.Builder{
            builderResult.hasIsGroup = false
            builderResult.isGroup = false
            return self
        }
        public var title:String {
            get {
                return builderResult.title
            }
            set (value) {
                builderResult.hasTitle = true
                builderResult.title = value
            }
        }
        public var hasTitle:Bool {
            get {
                return builderResult.hasTitle
            }
        }
        @discardableResult
        public func setTitle(_ value:String) -> Dialog.Builder {
            self.title = value
            return self
        }
        @discardableResult
        public func clearTitle() -> Dialog.Builder{
            builderResult.hasTitle = false
            builderResult.title = ""
            return self
        }
        public var uid:Array<Int32> {
            get {
                return builderResult.uid
            }
            set (array) {
                builderResult.uid = array
            }
        }
        @discardableResult
        public func setUid(_ value:Array<Int32>) -> Dialog.Builder {
            self.uid = value
            return self
        }
        @discardableResult
        public func clearUid() -> Dialog.Builder {
            builderResult.uid.removeAll(keepingCapacity: false)
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Dialog.Builder {
            builderResult = Dialog()
            return self
        }
        override public func clone() throws -> Dialog.Builder {
            return try Dialog.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Dialog {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Dialog {
            let returnMe:Dialog = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Dialog) throws -> Dialog.Builder {
            if other == Dialog() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasIsGroup {
                isGroup = other.isGroup
            }
            if other.hasTitle {
                title = other.title
            }
            if !other.uid.isEmpty {
                builderResult.uid += other.uid
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Dialog.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Dialog.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt64()

                case 16:
                    isGroup = try codedInputStream.readBool()

                case 26:
                    title = try codedInputStream.readString()

                case 34:
                    let length = Int(try codedInputStream.readRawVarint32())
                    let limit = try codedInputStream.pushLimit(byteLimit: length)
                    while (codedInputStream.bytesUntilLimit() > 0) {
                        builderResult.uid.append(try codedInputStream.readInt32())
                    }
                    codedInputStream.popLimit(oldLimit: limit)

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Dialog.Builder {
            let resultDecodedBuilder = Dialog.Builder()
            if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int64(jsonValueId)!
            } else if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int64(jsonValueId)
            }
            if let jsonValueIsGroup = jsonMap["isGroup"] as? Bool {
                resultDecodedBuilder.isGroup = jsonValueIsGroup
            }
            if let jsonValueTitle = jsonMap["title"] as? String {
                resultDecodedBuilder.title = jsonValueTitle
            }
            if let jsonValueUid = jsonMap["uid"] as? Array<Int> {
                var jsonArrayUid:Array<Int32> = []
                for oneValueUid in jsonValueUid {
                    jsonArrayUid.append(Int32(oneValueUid))
                }
                resultDecodedBuilder.uid = jsonArrayUid
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Dialog.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Dialog.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class User : GeneratedMessage {

    public static func == (lhs: User, rhs: User) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int32 = Int32(0)
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var name:String = ""
    public fileprivate(set) var hasName:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:id)
        }
        if hasName {
            try codedOutputStream.writeString(fieldNumber: 2, value:name)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt32Size(fieldNumber: 1)
        }
        if hasName {
            serialize_size += name.computeStringSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> User.Builder {
        return User.classBuilder() as! User.Builder
    }
    public func getBuilder() -> User.Builder {
        return classBuilder() as! User.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return User.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return User.Builder()
    }
    public func toBuilder() throws -> User.Builder {
        return try User.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:User) throws -> User.Builder {
        return try User.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasId {
            jsonMap["id"] = Int(id)
        }
        if hasName {
            jsonMap["name"] = name
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> User {
        return try User.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> User {
        return try User.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasName {
            output += "\(indent) name: \(name) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasName {
                hashCode = (hashCode &* 31) &+ name.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "User"
    }
    override public func className() -> String {
        return "User"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:User = User()
        public func getMessage() -> User {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int32 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int32) -> User.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> User.Builder{
            builderResult.hasId = false
            builderResult.id = Int32(0)
            return self
        }
        public var name:String {
            get {
                return builderResult.name
            }
            set (value) {
                builderResult.hasName = true
                builderResult.name = value
            }
        }
        public var hasName:Bool {
            get {
                return builderResult.hasName
            }
        }
        @discardableResult
        public func setName(_ value:String) -> User.Builder {
            self.name = value
            return self
        }
        @discardableResult
        public func clearName() -> User.Builder{
            builderResult.hasName = false
            builderResult.name = ""
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> User.Builder {
            builderResult = User()
            return self
        }
        override public func clone() throws -> User.Builder {
            return try User.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> User {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> User {
            let returnMe:User = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:User) throws -> User.Builder {
            if other == User() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasName {
                name = other.name
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> User.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> User.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt32()

                case 18:
                    name = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> User.Builder {
            let resultDecodedBuilder = User.Builder()
            if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int32(jsonValueId)
            } else if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int32(jsonValueId)!
            }
            if let jsonValueName = jsonMap["name"] as? String {
                resultDecodedBuilder.name = jsonValueName
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> User.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try User.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class DialogListContext : GeneratedMessage {

    public static func == (lhs: DialogListContext, rhs: DialogListContext) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.dialog == rhs.dialog)
        fieldCheck = fieldCheck && (lhs.user == rhs.user)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var dialog:Array<Dialog>  = Array<Dialog>()
    public fileprivate(set) var user:Array<User>  = Array<User>()
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        for oneElementDialog in dialog {
              try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementDialog)
        }
        for oneElementUser in user {
              try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementUser)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        for oneElementDialog in dialog {
            serialize_size += oneElementDialog.computeMessageSize(fieldNumber: 1)
        }
        for oneElementUser in user {
            serialize_size += oneElementUser.computeMessageSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> DialogListContext.Builder {
        return DialogListContext.classBuilder() as! DialogListContext.Builder
    }
    public func getBuilder() -> DialogListContext.Builder {
        return classBuilder() as! DialogListContext.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return DialogListContext.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return DialogListContext.Builder()
    }
    public func toBuilder() throws -> DialogListContext.Builder {
        return try DialogListContext.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:DialogListContext) throws -> DialogListContext.Builder {
        return try DialogListContext.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if !dialog.isEmpty {
            var jsonArrayDialog:Array<Dictionary<String,Any>> = []
            for oneValueDialog in dialog {
                let ecodedMessageDialog = try oneValueDialog.encode()
                jsonArrayDialog.append(ecodedMessageDialog)
            }
            jsonMap["dialog"] = jsonArrayDialog
        }
        if !user.isEmpty {
            var jsonArrayUser:Array<Dictionary<String,Any>> = []
            for oneValueUser in user {
                let ecodedMessageUser = try oneValueUser.encode()
                jsonArrayUser.append(ecodedMessageUser)
            }
            jsonMap["user"] = jsonArrayUser
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> DialogListContext {
        return try DialogListContext.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> DialogListContext {
        return try DialogListContext.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        var dialogElementIndex:Int = 0
        for oneElementDialog in dialog {
            output += "\(indent) dialog[\(dialogElementIndex)] {\n"
            output += try oneElementDialog.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            dialogElementIndex += 1
        }
        var userElementIndex:Int = 0
        for oneElementUser in user {
            output += "\(indent) user[\(userElementIndex)] {\n"
            output += try oneElementUser.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            userElementIndex += 1
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementDialog in dialog {
                hashCode = (hashCode &* 31) &+ oneElementDialog.hashValue
            }
            for oneElementUser in user {
                hashCode = (hashCode &* 31) &+ oneElementUser.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "DialogListContext"
    }
    override public func className() -> String {
        return "DialogListContext"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:DialogListContext = DialogListContext()
        public func getMessage() -> DialogListContext {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var dialog:Array<Dialog> {
            get {
                return builderResult.dialog
            }
            set (value) {
                builderResult.dialog = value
            }
        }
        @discardableResult
        public func setDialog(_ value:Array<Dialog>) -> DialogListContext.Builder {
            self.dialog = value
            return self
        }
        @discardableResult
        public func clearDialog() -> DialogListContext.Builder {
            builderResult.dialog.removeAll(keepingCapacity: false)
            return self
        }
        public var user:Array<User> {
            get {
                return builderResult.user
            }
            set (value) {
                builderResult.user = value
            }
        }
        @discardableResult
        public func setUser(_ value:Array<User>) -> DialogListContext.Builder {
            self.user = value
            return self
        }
        @discardableResult
        public func clearUser() -> DialogListContext.Builder {
            builderResult.user.removeAll(keepingCapacity: false)
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> DialogListContext.Builder {
            builderResult = DialogListContext()
            return self
        }
        override public func clone() throws -> DialogListContext.Builder {
            return try DialogListContext.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> DialogListContext {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> DialogListContext {
            let returnMe:DialogListContext = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:DialogListContext) throws -> DialogListContext.Builder {
            if other == DialogListContext() {
                return self
            }
            if !other.dialog.isEmpty  {
                 builderResult.dialog += other.dialog
            }
            if !other.user.isEmpty  {
                 builderResult.user += other.user
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> DialogListContext.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DialogListContext.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder = Dialog.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    dialog.append(subBuilder.buildPartial())

                case 18:
                    let subBuilder = User.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    user.append(subBuilder.buildPartial())

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> DialogListContext.Builder {
            let resultDecodedBuilder = DialogListContext.Builder()
            if let jsonValueDialog = jsonMap["dialog"] as? Array<Dictionary<String,Any>> {
                var jsonArrayDialog:Array<Dialog> = []
                for oneValueDialog in jsonValueDialog {
                    let messageFromStringDialog = try Dialog.Builder.decodeToBuilder(jsonMap:oneValueDialog).build()

                    jsonArrayDialog.append(messageFromStringDialog)
                }
                resultDecodedBuilder.dialog = jsonArrayDialog
            }
            if let jsonValueUser = jsonMap["user"] as? Array<Dictionary<String,Any>> {
                var jsonArrayUser:Array<User> = []
                for oneValueUser in jsonValueUser {
                    let messageFromStringUser = try User.Builder.decodeToBuilder(jsonMap:oneValueUser).build()

                    jsonArrayUser.append(messageFromStringUser)
                }
                resultDecodedBuilder.user = jsonArrayUser
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> DialogListContext.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try DialogListContext.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension Dialog: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Dialog> {
        var mergedArray = Array<Dialog>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Dialog? {
        return try Dialog.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Dialog {
        return try Dialog.Builder().mergeFrom(data: data, extensionRegistry:DialogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Dialog {
        return try Dialog.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Dialog {
        return try Dialog.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Dialog {
        return try Dialog.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Dialog {
        return try Dialog.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Dialog {
        return try Dialog.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "isGroup": return self.isGroup
        case "title": return self.title
        case "uid": return self.uid
        default: return nil
        }
    }
}
extension Dialog.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "isGroup": return self.isGroup
            case "title": return self.title
            case "uid": return self.uid
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.id = newSubscriptValue
            case "isGroup":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isGroup = newSubscriptValue
            case "title":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.title = newSubscriptValue
            case "uid":
                guard let newSubscriptValue = newSubscriptValue as? Array<Int32> else {
                    return
                }
                self.uid = newSubscriptValue
            default: return
            }
        }
    }
}
extension User: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<User> {
        var mergedArray = Array<User>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> User? {
        return try User.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> User {
        return try User.Builder().mergeFrom(data: data, extensionRegistry:DialogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> User {
        return try User.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> User {
        return try User.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> User {
        return try User.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> User {
        return try User.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> User {
        return try User.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "name": return self.name
        default: return nil
        }
    }
}
extension User.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "name": return self.name
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.id = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            default: return
            }
        }
    }
}
extension DialogListContext: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<DialogListContext> {
        var mergedArray = Array<DialogListContext>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> DialogListContext? {
        return try DialogListContext.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> DialogListContext {
        return try DialogListContext.Builder().mergeFrom(data: data, extensionRegistry:DialogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> DialogListContext {
        return try DialogListContext.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> DialogListContext {
        return try DialogListContext.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> DialogListContext {
        return try DialogListContext.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> DialogListContext {
        return try DialogListContext.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DialogListContext {
        return try DialogListContext.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "dialog": return self.dialog
        case "user": return self.user
        default: return nil
        }
    }
}
extension DialogListContext.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "dialog": return self.dialog
            case "user": return self.user
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "dialog":
                guard let newSubscriptValue = newSubscriptValue as? Array<Dialog> else {
                    return
                }
                self.dialog = newSubscriptValue
            case "user":
                guard let newSubscriptValue = newSubscriptValue as? Array<User> else {
                    return
                }
                self.user = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
